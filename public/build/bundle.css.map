{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "Route.svelte",
    "Router.svelte"
  ],
  "sourcesContent": [
    "<script context=\"module\">\n  import { writable } from 'svelte/store';\n  import { routeInfo } from './router';\n  import {\n    CTX_ROUTER, CTX_ROUTE, getProps, isPromise, isSvelteComponent,\n  } from './utils';\n</script>\n\n<script>\n  import { onDestroy, getContext, setContext } from 'svelte';\n\n  export let key = null;\n  export let path = '/';\n  export let exact = null;\n  export let pending = null;\n  export let disabled = false;\n  export let fallback = null;\n  export let component = null;\n  export let condition = null;\n  export let redirect = null;\n\n  // replacement for `Object.keys(arguments[0].$$.props)`\n  const thisProps = ['key', 'path', 'exact', 'pending', 'disabled', 'fallback', 'component', 'condition', 'redirect'];\n\n  const routeContext = getContext(CTX_ROUTE);\n  const routerContext = getContext(CTX_ROUTER);\n\n  const { assignRoute, unassignRoute } = routerContext || {};\n\n  const routePath = routeContext ? routeContext.routePath : writable(path);\n\n  let activeRouter = null;\n  let activeProps = {};\n  let fullpath;\n  let failure;\n  let hasLoaded;\n\n  const fixedRoot = $routePath !== path && $routePath !== '/'\n    ? `${$routePath}${path !== '/' ? path : ''}`\n    : path;\n\n  try {\n    if (redirect !== null && !/^(?:\\w+:\\/\\/|\\/)/.test(redirect)) {\n      throw new TypeError(`Expecting valid URL to redirect, given '${redirect}'`);\n    }\n\n    if (condition !== null && typeof condition !== 'function') {\n      throw new TypeError(`Expecting condition to be a function, given '${condition}'`);\n    }\n\n    if (path.charAt() !== '#' && path.charAt() !== '/') {\n      throw new TypeError(`Expecting a leading slash or hash, given '${path}'`);\n    }\n\n    if (!assignRoute) {\n      throw new TypeError(`Missing top-level <Router>, given route: ${path}`);\n    }\n\n    const fixedRoute = path !== fixedRoot && fixedRoot.substr(-1) !== '/'\n      ? `${fixedRoot}/`\n      : fixedRoot;\n\n    [key, fullpath] = assignRoute(key, fixedRoute, {\n      condition, redirect, fallback, exact,\n    });\n  } catch (e) {\n    failure = e;\n  }\n\n  $: if (key) {\n    activeRouter = !disabled && $routeInfo[key];\n    activeProps = getProps($$props, thisProps);\n  }\n\n  $: if (activeRouter) {\n    if (!component) { // component passed as slot\n      hasLoaded = true;\n    } else if (isSvelteComponent(component)) { // component passed as Svelte component\n      hasLoaded = true;\n    } else if (isPromise(component)) { // component passed as import()\n      component.then(module => {\n        component = module.default;\n        hasLoaded = true;\n      });\n    } else { // component passed as () => import()\n      component().then(module => {\n        component = module.default;\n        hasLoaded = true;\n      });\n    }\n  }\n\n  onDestroy(() => {\n    if (unassignRoute) {\n      unassignRoute(fullpath);\n    }\n  });\n\n  setContext(CTX_ROUTE, {\n    routePath,\n  });\n</script>\n\n<style>\n  [data-failure] {\n    color: red;\n  }\n</style>\n\n{#if failure}\n  <p data-failure>{failure}</p>\n{/if}\n\n{#if activeRouter}\n  {#if !hasLoaded}\n    {#if pending}\n      {#if isSvelteComponent(pending)}\n        <svelte:component this={pending} router={activeRouter} {...activeProps} />\n      {:else}\n        {pending}\n      {/if}\n    {/if}\n  {:else}\n    {#if component}\n      <svelte:component this={component} router={activeRouter} {...activeProps} />\n    {:else}\n      <slot router={activeRouter} props={activeProps} />\n    {/if}\n  {/if}\n{/if}\n",
    "<script context=\"module\">\n  import { writable } from 'svelte/store';\n  import { CTX_ROUTER, router } from './utils';\n  import {\n    baseRouter, addRouter, findRoutes, doFallback,\n  } from './router';\n</script>\n\n<script>\n  import {\n    onMount, onDestroy, getContext, setContext,\n  } from 'svelte';\n\n  let cleanup;\n  let failure;\n  let fallback;\n\n  export let path = '/';\n  export let disabled = false;\n  export let condition = null;\n  export let nofallback = false;\n\n  const routerContext = getContext(CTX_ROUTER);\n  const basePath = routerContext ? routerContext.basePath : writable(path);\n\n  const fixedRoot = $basePath !== path && $basePath !== '/'\n    ? `${$basePath}${path !== '/' ? path : ''}`\n    : path;\n\n  try {\n    if (condition !== null && typeof condition !== 'function') {\n      throw new TypeError(`Expecting condition to be a function, given '${condition}'`);\n    }\n\n    if (path.charAt() !== '#' && path.charAt() !== '/') {\n      throw new TypeError(`Expecting a leading slash or hash, given '${path}'`);\n    }\n  } catch (e) {\n    failure = e;\n  }\n\n  function assignRoute(key, route, detail) {\n    key = key || Math.random().toString(36).substr(2);\n\n    // consider as nested routes if they does not have any segment\n    const nested = !route.substr(1).includes('/');\n    const handler = { key, nested, ...detail };\n\n    let fullpath;\n\n    baseRouter.mount(fixedRoot, () => {\n      fullpath = baseRouter.add(route, handler);\n      fallback = (handler.fallback && key) || fallback;\n    });\n\n    findRoutes();\n\n    return [key, fullpath];\n  }\n\n  function unassignRoute(route) {\n    try {\n      baseRouter.rm(route);\n    } catch (e) {\n      // ðŸ”¥ this is fine...\n    }\n    findRoutes();\n  }\n\n  function onError(err) {\n    failure = err;\n\n    if (failure && fallback) {\n      doFallback(failure, fallback);\n    }\n  }\n\n  onMount(() => {\n    cleanup = addRouter(fixedRoot, fallback, onError);\n  });\n\n  onDestroy(() => {\n    if (cleanup) cleanup();\n  });\n\n  setContext(CTX_ROUTER, {\n    basePath,\n    assignRoute,\n    unassignRoute,\n  });\n\n  $: if (condition) {\n    disabled = !condition($router);\n  }\n</script>\n\n<style>\n  [data-failure] {\n    border: 1px dashed silver;\n  }\n</style>\n\n{#if !disabled}\n  <slot />\n{/if}\n\n{#if failure && !fallback && !nofallback}\n  <fieldset data-failure>\n    <legend>Router failure: {path}</legend>\n    <pre>{failure}</pre>\n  </fieldset>\n{/if}\n"
  ],
  "names": [],
  "mappings": "AAwGE,CAAC,YAAY,CAAC,cAAC,CAAC,AACd,KAAK,CAAE,GAAG,AACZ,CAAC;ACTD,CAAC,YAAY,CAAC,cAAC,CAAC,AACd,MAAM,CAAE,GAAG,CAAC,MAAM,CAAC,MAAM,AAC3B,CAAC"
}